import * as core from './core.js';
import * as base from './_grapheme_table.js';

/**
 * @typedef {(
 *   | GS_Unknown
 *   | GS_NotBreak
 *   | GS_Break
 *   | GS_Regional
 *   | GS_Emoji
 * )} GraphemeState
 */
/** No information is known */
const GS_Unknown = 0;
/** It is known to not be a boundary. */
const GS_NotBreak = 1;
/** It is known to be a boundary. */
const GS_Break = 2;
/** The codepoint after is a Regional Indicator Symbol, so a boundary iff it is preceded by an even number of RIS codepoints. (GB12, GB13) */
const GS_Regional = 3;
/** The codepoint after is Extended_Pictographic, so whether it's a boundary depends on pre-context according to GB11. */
const GS_Emoji = 4;

/**
 * @param {string} input
 * @return {core.Segmenter}
 */
export function* graphemeSegments(input) {
  // do nothing on empty string
  if (input === '') {
    return;
  }

  /** @type {number} Current cursor position. */
  let cursor = 0;

  /** @type {number} Total length of the input string. */
  let len = input.length;

  /** @type {GraphemeState} Information about the potential boundary at `cursor` */
  let state = GS_Break;

  /** @type {base.GraphemeCategory | null} Category of codepoint immediately preceding cursor, if known. */
  let catBefore = null;

  /** @type {base.GraphemeCategory | null} Category of codepoint immediately preceding cursor, if known. */
  let catAfter = null;

  /** @type {base.GraphemeSearchResult} */
  let cache = [0, 0, base.GC_Control];

  /** @type {number | null} The number of RIS codepoints preceding `cursor`. */
  let risCount = 0;

  /**
   * @return {core.Uchar}
   * Take a u32 char from the current cursor
   */
  let take = () => {
    let hi = input.charCodeAt(cursor);
    if (0xd800 <= hi && hi <= 0xdbff) {
      if (cursor + 1 < len) {
        let lo = input.charCodeAt(cursor + 1);
        if (0xdc00 <= lo && 0xffff) {
          return String.fromCodePoint(((hi - 0xD800) << 10) + (lo - 0xDC00) + 0x10000);
        }
      }
    }
    return String.fromCodePoint(hi);
  };

  /**
   * @param {boolean} isBreak
   * @return {boolean} Identity
   */
  let decision = (isBreak) => {
    state = isBreak ? GS_Break : GS_NotBreak;
    return isBreak;
  };

  /**
   * @param {core.Uchar} ch
   * @return {base.GraphemeCategory}
   */
  let categoryOf = (ch) => {
    if (ch <= '\u{007e}') {
      // Special-case optimization for ascii, except U+007F.  This
      // improves performance even for many primarily non-ascii texts,
      // due to use of punctuation and white space characters from the
      // ascii range.
      if (ch >= '\u{0020}') {
        return base.GC_Any;
      } else if (ch == '\n') {
        return base.GC_LF;
      } else if (ch == '\r') {
        return base.GC_CR;
      } else {
        return base.GC_Control;
      }
    } else {
      let cp = ch.codePointAt(0);
      // If this char isn't within the cached range, update the cache to the
      // range that includes it.
      if (cp < cache[0] || cp > cache[1]) {
        cache = base.searchGrapheme(ch);
      }
      return cache[2];
    }
  };

  /**
   * @return {boolean}
   */
  let isBoundary = () => {
    if (catBefore === null || catAfter === null) {
      throw new RangeError('Segments isn\'t intialized');
    }
    if (state === GS_Break) {
      return true;
    }
    if (state === GS_NotBreak) {
      return false;
    }
    switch (checkPair(catBefore, catAfter)) {
      case P_NotBreak:
        return decision(false);
      case P_Break:
      case P_Extended:
        return decision(true);
      case P_Regional:
        return decision(risCount % 2 === 0);
      case P_Emoji:
        // Here is always ZWJ + emoji combo
        return decision(false);
    }
  };



  let ch = take();
  let segment = ch;

  while (true) {
    cursor += ch.length;

    let index = cursor - segment.length;

    if (cursor === len) {
      yield { segment, input, index };
      break;
    }

    state = GS_Unknown;

    catBefore = catAfter;
    if (catBefore === null) {
      catBefore = categoryOf(ch);
    }

    if (catBefore === base.GC_Regional_Indicator) {
      risCount += 1;
    } else {
      risCount = 0;
    }

    ch = take();
    catAfter = categoryOf(ch);

    if (isBoundary()) {
      yield { segment, input, index };
      segment = '';
    }

    segment += ch;
  }
}

/**
 * @typedef {(
 *   | P_NotBreak
 *   | P_Break
 *   | P_Extended
 *   | P_Regional
 *   | P_Emoji
 * )} PairResult
 */
const P_NotBreak = 0;
const P_Break = 1;
const P_Extended = 2;
const P_Regional = 3;
const P_Emoji = 4;

/**
 * @param {base.GraphemeCategory} before
 * @param {base.GraphemeCategory} after
 * @return {PairResult}
 *
 * Generated by ReScript v11.0.1
 * https://rescript-lang.org/try?version=v11.0.1&code=C4TwDgpgBAxghsKBeAUFKAfKABOBnACgAYBKKAcQGEB9AQQDsQ1Md8CBGMq6ygJWay5CAJi41KAe3rAAThIA2A1oQDMY6gFEAHsAj0AJkqEEALOu26DEfdQAKASxjAJAcxlwwAC0dG2AVnUAGV9CADYggDEQggB2IIA1aIAOBIAVaIBOdVsZCEgDaPZSChpeCBd7KTh5agBJA0cECRlCzhLqAGUwOBh7ehcAWTgZAGtC0Xb09EE2djV2xOnlDjN2gC0AdQApFBRQSChu+xkyvABXeURUJeNigDkJYAAhXLgxm9myF4g36ImLPT6azReZlCpVRQfQirDQAWwkACt7Lt5BBEDBPBAYCNbHBjsgoAQAEYQABmzQgABooHBSboZGQkAA+Zh4ADu9mAGMJJPJuWptPpZAA3koCNw+NTuIEIoymVAHs9XiMoAB6VUUJ4qMUSqSyBTU6hyqDfN5qjXkJ4mHXiXiG42mlXqzXWpbimgy+3IeWO80usXUKXiPVyeQO5V+y1+ANBni8cM-J0Wp7Rt2B9oyhNm51Rm3UQKxwLGxW+nNPUJ5gsLYuPUvJitu6WF+I1pWJyPlyvN1Ktuuahssd35+KxlvehW1iNlmKVkeTXtT5Mzxs0OfcMfMidt7NLvNrmg98clxea5eD6XxVKxw+b4-tstJPNX+dHyf35OPtOxgEGBfvzUZDG6zbH+O4AUB3BdD0fSDMMIzGj+QL6B2GRwHmOR5ICXqboh1goUSeabFs346IC1h2I4zhuB43gwAh8JIh27DsHmYKVPQ1R1A08DODIsZsRCXH6I0vHGgJHHyExwhSk8cxAUa459paGQqcwAC+KBAA
 */
function checkPair(before, after) {
  switch (before) {
    case 1 :
        if (after === 6) {
          return 0;
        } else {
          return 1;
        }
    case 5 :
        switch (after) {
          case 0 :
          case 4 :
          case 9 :
          case 10 :
          case 12 :
              return 1;
          case 5 :
          case 7 :
          case 8 :
          case 13 :
              return 0;
          default:
            
        }
        break;
    case 2 :
    case 6 :
        return 1;
    case 7 :
        switch (after) {
          case 12 :
          case 13 :
              return 0;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    case 8 :
        switch (after) {
          case 12 :
              return 0;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    case 10 :
        switch (after) {
          case 10 :
              return 3;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    case 12 :
        switch (after) {
          case 12 :
              return 0;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    case 13 :
        switch (after) {
          case 12 :
          case 13 :
              return 0;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    case 14 :
        switch (after) {
          case 4 :
              return 4;
          case 1 :
          case 2 :
          case 3 :
          case 6 :
          case 11 :
          case 14 :
              break;
          default:
            return 1;
        }
        break;
    default:
      
  }
  switch (after) {
    case 1 :
    case 2 :
    case 6 :
        return 1;
    case 11 :
        return 2;
    case 3 :
    case 14 :
        return 0;
    default:
      if (before === 9) {
        return 2;
      } else {
        return 1;
      }
  }
}
